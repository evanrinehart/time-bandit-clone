{-# LANGUAGE GADTs #-}
{-# LANGUAGE KindSignatures #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE ScopedTypeVariables #-}
module Event where

import Prelude hiding (id, (.))
import Control.Category
import qualified Data.HashMap.Strict as H
import System.Mem.StableName
import Unsafe.Coerce
import Poke
import Prediction
import Port
import Plan
import Control.Monad (when)
import Viewing

data Event :: * -> * -> * -> * where
  ENever :: Event dt s a
  EPrediction :: Pred dt s a -> Event dt s a
  EPort :: Port a -> Event dt s a
  EGate :: (s -> Bool) -> Event dt s a -> Event dt s a
  EJust :: Event dt s (Maybe a) -> Event dt s a
  EMap :: (a -> b) -> Event dt s a -> Event dt s b
  ECat :: Event dt s a -> Event dt s a -> Event dt s a

instance Functor (Event dt s) where
  fmap = EMap

instance Monoid (Event dt s a) where
  mempty = ENever
  mappend = ECat

predict :: Plan s (Prediction dt a) -> Event dt s a
predict = EPrediction

onPort :: Port a -> Event dt s a
onPort = EPort

onJust :: Event dt s (Maybe a) -> Event dt s a
onJust = EJust
    
fromEvent :: Event dt s a -> PrSet dt s -> IO (PrSet dt s)
fromEvent e0 hm = case e0 of
  EPrediction pred -> do
    name <- PrName <$> (makeStableName $! pred)
    if H.member name hm
      then return hm
      else return (H.insert name (AnyPred pred) hm)
  ECat e1 e2 -> fromEvent e1 hm >>= fromEvent e2
  EMap f e -> fromEvent e hm
  EGate check e -> fromEvent e hm
  _ -> return hm

-- produce a prioritized set of Pokes from a prediction plan object
-- and the predicted value... for 1 rule.
applyPred :: forall a dt s
           . Int -- rule number
          -> Pred dt s a -- prediction plan
          -> a -- predicted value
          -> Event dt s (Poke s ())
          -> [((Int,Int),Poke s ())]
applyPred ruleNo pred0 x e0 = fst $ go id e0 [] 0 where
  go :: forall b
      . (b -> Poke s ())
     -> Event dt s b
     -> [((Int,Int),Poke s ())]
     -> Int
     -> ([((Int,Int),Poke s ())],Int)
  go f e outs order = case e of
    EPrediction pred1 -> case predCoerce pred0 pred1 x of
      Nothing -> (outs, order)
      Just x' -> ((((ruleNo, order), f x') : outs), order)
    ECat e1 e2 ->
      let (outs', order') = go f e1 outs order in
      go f e2 outs' (order' + 1)
    EMap g e' -> go (f . g) e' outs order
    EGate check e' -> (subpokes', order') where
      (subpokes, order') = go f e' [] order
      on2 f (x,y) = (x, f y)
      g poke = check <$> view id >>= flip when poke
      subpokes' = map (on2 g) subpokes 
    _ -> (outs, order)

-- returns the pokes generated by a port write
applyPortWrite :: Port a -> a -> Event dt s (Poke s ()) -> [Poke s ()]
applyPortWrite port x e0 = reverse (go id e0 []) where
  go :: forall b s dt
      . (b -> Poke s ())
     -> Event dt s b
     -> [Poke s ()]
     -> [Poke s ()]
  go f e outs = case e of
    EPort port' -> case portCoerce port port' x of
      Nothing -> outs
      Just x' -> (f x' : outs)
    ECat e1 e2 ->
      let outs' = go f e1 outs in
      go f e2 outs'
    EMap g e' -> go (f . g) e' outs
    EGate check e' -> subpokes' where
      subpokes = go f e' []
      g poke = check <$> view id >>= flip when poke
      subpokes' = map g subpokes 
    _ -> outs
  
